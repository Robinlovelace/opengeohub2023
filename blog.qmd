---
# This has become sufficiently long that it's worth having a separate post for raster data IMO (RL)
title: "Geographic data analysis in R and Python: comparing code and outputs for working with vector datasets"
# # Alternative title:
# title: "Teaching R and Python for geographic data: shared experiences and lessons learned"
# Render on save: true
---

```{r}
#| include: false
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
# install python packages needed for this document:
pkgs = c("geopandas", "shapely", "pandas", "rasterio", "matplotlib", "folium", "mapclassify")
reticulate::py_install(pkgs)
```

# Introduction

In this blog post, we talk about our experience teaching R and Python for geocomputation.
The focus of the blog post is on geographic vector data, meaning points, lines, polygons (and their 'multi' variants) and the attributes associated with them.

Geographic data analysis is a broad topic and in a later post we will cover raster data, meaning gridded data such as satellite images.

 <!---
 broadly defined as [follows](https://r.geocompx.org/intro#what-is-geocomputation):

> Working with geographic data in a computational way, focusing on code, reproducibility and modularity. 
--->
The context of this blog post is the [OpenGeoHub Summer School 2023](https://opengeohub.org/summer-school/opengeohub-summer-school-poznan-2023/) which has courses on R, Python and Julia.
The size and the diversity of the event has grown over the years.
Noting that many events focus on just one language, and the advantages of diversity of languages and approaches, we wanted to follow-up in a blog post that could be useful to others.

OpenGeoHub 2023 was also a unique chance for the authors of the in-progress open source book, [Geocomputation with Python](https://py.geocompx.org/) to meet in person: the first time we have all been in one place at the same time.

The post is based on the following lecture notes, which we recommend checking out for deeper dives into the R and Python implementations of geocomputation:

- [Tidy geographic data with sf, dplyr, ggplot2, geos and friends](https://ogh23.robinlovelace.net/tidy)
- [Working with Spatial Data in Python](https://geobgu.xyz/presentations/p_2023_ogh/)

<!---
 TODO: Add video links 
--->


# Comparing R and Python for vector geographic data analysis

## Loading packages

We will start by loading core packages for working with geographic vector and attribute data.
See detailed description of [R](https://ogh23.robinlovelace.net/tidy#vector-data) and [Python](https://geobgu.xyz/presentations/p_2023_ogh/01-vector.html) implementations in the respective lecture note sections.


::: {.panel-tabset group="language"}

## Python

```{python}
import pandas as pd
from shapely import Point
import geopandas as gpd
```

## R

```{r}
library(sf)
library(tidyverse)
library(tmap)
```

:::

## Creating geographic data

The following commands create geographic datasets 'from scratch'.
Most projects start with pre-generated data, but it's useful to create datasets to understand data structures.

::: {.panel-tabset group="language"}

## Python

```{python}
poi = gpd.GeoDataFrame([
    {"name": "Faculty",        "geometry": Point(16.9418, 52.4643)},
    {"name": "Hotel ForZa",    "geometry": Point(16.9474, 52.4436)},
    {"name": "Hotel Lechicka", "geometry": Point(16.9308, 52.4437)},
    {"name": "FairPlayce",     "geometry": Point(16.9497, 52.4604)},
], crs=4326)
```

## R

```{r}
poi_df = tribble(
  ~name, ~lon, ~lat,
  "Faculty",        16.9418, 52.4643,
  "Hotel ForZa",    16.9474, 52.4436,
  "Hotel Lechicka", 16.9308, 52.4437,
  "FairPlayce",     16.9497, 52.4604
)
poi_sf = sf::st_as_sf(poi_df, coords = c("lon", "lat"))
sf::st_crs(poi_sf) = "EPSG:4326"
```


:::

### Downloading data

The following commands download data from the internet.

::: {.panel-tabset group="language"}

## Python

```{python}
import urllib.request
import zipfile
import os
u = "https://github.com/Robinlovelace/opengeohub2023/releases/download/data/data.zip"
f = os.path.basename(u)
if not os.path.exists("data"):
    urllib.request.urlretrieve(u, f)
```

## R

```{r}
u = "https://github.com/Robinlovelace/opengeohub2023/releases/download/data/data.zip"
f = basename(u)
if (!dir.exists("data")) {
  download.file(u, f)
  unzip(f)
}
```

Note that, for R, we also unzip the dataset. This is not necessary for Python, since GeoPandas can read directly from ZIP files.

:::

## Reading and printing geographic data

As shown below, Python and R implemenations to import a shapefile are similar.

::: {.panel-tabset group="language"}

## Python

```{python}
pol_all = gpd.read_file("zip://data.zip!data/osm/gis_osm_transport_a_free_1.shp")
pol_all
```

## R

```{r}
pol_all = sf::read_sf("data/osm/gis_osm_transport_a_free_1.shp")
pol_all
```

:::

## Subsetting by attributes

The following commands select a subset of the data based on attribute values.

::: {.panel-tabset group="language"}

## Python

```{python}
pol = pol_all[pol_all['name'].str.contains('Port*.+Poz', na=False)]
pol
```

## R

```{r}
pol = pol_all |>
  filter(str_detect(name, "Port*.+Poz"))
pol
```

:::

## Basic plotting

The following commands plot the data.
Note that by default, R's `plot()` method for `{sf}` objects creates a plot for each column in the data (up to 9 by default).

::: {.panel-tabset group="language"}

## Python

```{python}
pol.plot();
```

## R

```{r}
plot(pol)
```

:::

The arguments needed to change the colour of the fill and border are different in R and Python, but the results are similar.

::: {.panel-tabset group="language"}

## Python

```{python}
pol.plot(color='none', edgecolor='black');
```

## R

```{r}
plot(pol$geometry, col = "white", border = "black")
```

:::

## Creating geographic data frames from a CSV file

The following commands create a geographic data frame from a CSV file.
Note that separate steps are needed to grom a GeoSeries to a GeoDataFrame in Python, whereas in R the `sf::st_as_sf()` function can be used to convert a data frame to a spatial data frame directly.

::: {.panel-tabset group="language"}

## Python

```{python}
stops = pd.read_csv("data/gtfs/stops.txt")
stops = gpd.GeoDataFrame(
    stops.drop(columns=['stop_lon', 'stop_lat', 'stop_code']),
    geometry = gpd.points_from_xy(stops.stop_lon, stops.stop_lat),
    crs = 4326)
```

## R

```{r}
stops = read_csv("data/gtfs/stops.txt") |>
  select(-stop_code) |>
  st_as_sf(coords = c("stop_lon", "stop_lat"), crs = 4326)
stops
```

:::

## Plotting attributes and layers

The following commands plot the bus stops loaded in the previous step.
Note that the `tmap` package is used in R to create these more advanced plots, as it also supports interactive mapping.

::: {.panel-tabset group="language"}

## Python

```{python}
stops.plot(markersize=1, column='zone_id', legend=True, cmap='Dark2');
```

## R

```{r}
tm_shape(stops) +
  tm_dots(size = 0.1, col = "zone_id")
```

:::

We can add basic overlays easily in both languages.

::: {.panel-tabset group="language"}

## Python

```{python}
base = stops.plot(markersize=0.1)
poi.plot(ax=base, color='red');
```

## R

```{r}
plot(stops$geometry, col = "grey", pch = 20, cex = 0.5)
plot(poi_sf$geometry, col = "red", add = TRUE)
```

:::

## Interactive plots

The following commands create interactive plots, in Python and R respectively.
The Python code requires `folium` and `mapclassify` packages, which are not installed by default when you install `geopandas`.
Note that with `{tmap}` you can use the same code to create static and interactive plots, by changing the `tmap_mode()`. 

::: {.panel-tabset group="language"}

## Python

```{python}
stops.explore(column='zone_id', legend=True, cmap='Dark2')
```

## R

```{r}
tmap_mode("view")
tm_shape(stops) +
  tm_dots(size = 0.1, col = "zone_id")
```

:::

## Reprojecting data

The following commands reproject the data to a local coordinate reference system (CRS).

::: {.panel-tabset group="language"}

## Python

```{python}
poi.crs
poi_projected = poi.to_crs(2180)
stops_projected = stops.to_crs(2180)
```

## R

```{r}
st_crs(poi_sf)
poi_projected = st_transform(poi_sf, 2180)
stops_projected = st_transform(stops, 2180)
```

:::

## Buffers

The following commands create a buffer around the points.
Note that R allows buffer to be created directly from a spatial data frame with geographic (lon/lot) coordinates thanks to its integration with Google's S2 spherical geometry engine.
For buffer operations to work in Python you must reproject the data first (although there plans for GeoPandas to support a spherical geometry backend at some point, as discussed in issue [#2098](https://github.com/geopandas/geopandas/issues/2098)).


::: {.panel-tabset group="language"}

## Python

<!---
 TODO: can we improve this? 
--->

```{python}
b = poi_projected.buffer(150)
poi_projected['buffer_150'] = b
poi_projected = poi_projected.rename(columns={'geometry': 'point'})
poi_projected = poi_projected.set_geometry('buffer_150')
poi_buffer = poi_projected.to_crs(4326)
```

## R

```{r}
poi_buffer = sf::st_buffer(poi_sf, 150)
```

:::

## Calculating distances and areas

An interesting difference between R and Python is that the former uses the `units` package to store units, making it easy to convert between them, as outlined in the [buffers section of the R lecture notes](https://ogh23.robinlovelace.net/tidy#buffers).

::: {.panel-tabset group="language"}

## Python

```{python}
poi_buffer.to_crs(2180).area
```

## R

```{r}
st_area(poi_buffer)
```

:::

## Spatial subsetting

Code to subset the bus stops withing the buffered `poi` points is shown below.
As shown, the R is more concise because in Python you must undertake a few additional steps:

- Take the unary union of the buffered points before subsetting
- Create a boolean Series object with the `contains()` or other method and use the boolean Series to subset the data (rather than another geographic object)

::: {.panel-tabset group="language"}

## Python

```{python}
poi_union = poi_buffer.unary_union
sel = stops.intersects(poi_union)
stops_in_b = stops[sel]
stops_in_b
```

## R

```{r}
stops_in_b = stops[poi_buffer, ]
stops_in_b
```

:::

## Spatial joins

Spatial joins work slightly differently in R and Python.
In Python, the operation returns the geometry of both 'x' and 'y' objects, which could be useful for further analysis.

::: {.panel-tabset group="language"}

## Python

```{python}
poi_buffer.sjoin(stops, how='left')
```

## R

```{r}
st_join(stops, poi_buffer)
```

:::



# Further reading

- A great tutorial that simultaneously covers R and Python is [Tools and packages to query and process Sentinel-1 and Sentinel-2 data with R and Python](https://github.com/loreabad6/ogh23) by Lorena Abad.
